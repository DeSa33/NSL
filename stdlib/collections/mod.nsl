// NSL Standard Library - Collections Module
// Provides collection manipulation functionality
//
// Usage:
//   import { map, filter, reduce, find, sort } from collections
//
// Functional-style operations on arrays/vectors

module collections {
    // Map function over array, returning new array
    // f: function to apply to each element
    pub fn map(arr, f) {
        let n = len(arr)
        mut result = zeros(n)
        for i in 0..n {
            result[i] = f(arr[i])
        }
        return result
    }

    // Filter array by predicate, returning matching elements
    // pred: function returning bool
    pub fn filter(arr, pred) {
        let n = len(arr)
        mut result = []
        for i in 0..n {
            if pred(arr[i]) {
                result = result + [arr[i]]
            }
        }
        return result
    }

    // Reduce array to single value
    // f: (accumulator, element) => new_accumulator
    // initial: starting value
    pub fn reduce(arr, f, initial) {
        mut acc = initial
        let n = len(arr)
        for i in 0..n {
            acc = f(acc, arr[i])
        }
        return acc
    }

    // Find first element matching predicate
    // Returns some(element) or none
    pub fn find(arr, pred) {
        let n = len(arr)
        for i in 0..n {
            if pred(arr[i]) {
                return some(arr[i])
            }
        }
        return none
    }

    // Check if any element matches predicate
    pub fn any(arr, pred) {
        let n = len(arr)
        for i in 0..n {
            if pred(arr[i]) {
                return true
            }
        }
        return false
    }

    // Check if all elements match predicate
    pub fn all(arr, pred) {
        let n = len(arr)
        for i in 0..n {
            if not pred(arr[i]) {
                return false
            }
        }
        return true
    }

    // Get first element (or none if empty)
    pub fn first(arr) {
        if len(arr) == 0 {
            return none
        }
        return some(arr[0])
    }

    // Get last element (or none if empty)
    pub fn last(arr) {
        let n = len(arr)
        if n == 0 {
            return none
        }
        return some(arr[n - 1])
    }

    // Take first n elements
    pub fn take(arr, n) {
        let arrlen = len(arr)
        let count = if n < arrlen { n } else { arrlen }
        mut result = []
        for i in 0..count {
            result = result + [arr[i]]
        }
        return result
    }

    // Skip first n elements
    pub fn skip(arr, n) {
        let arrlen = len(arr)
        if n >= arrlen {
            return []
        }
        mut result = []
        for i in n..arrlen {
            result = result + [arr[i]]
        }
        return result
    }

    // Reverse array
    pub fn reverse(arr) {
        let n = len(arr)
        mut result = zeros(n)
        for i in 0..n {
            result[i] = arr[n - 1 - i]
        }
        return result
    }

    // Zip two arrays together
    pub fn zip(a, b) {
        let na = len(a)
        let nb = len(b)
        let n = if na < nb { na } else { nb }
        mut result = []
        for i in 0..n {
            result = result + [[a[i], b[i]]]
        }
        return result
    }

    // Sum of numeric array
    pub fn sum_all(arr) {
        return sum(arr)
    }

    // Average of numeric array
    pub fn average(arr) {
        return mean(arr)
    }

    // Min value in array
    pub fn min_val(arr) {
        let n = len(arr)
        if n == 0 {
            return none
        }
        mut m = arr[0]
        for i in 1..n {
            if arr[i] < m {
                m = arr[i]
            }
        }
        return some(m)
    }

    // Max value in array
    pub fn max_val(arr) {
        let n = len(arr)
        if n == 0 {
            return none
        }
        mut m = arr[0]
        for i in 1..n {
            if arr[i] > m {
                m = arr[i]
            }
        }
        return some(m)
    }

    // Count elements matching predicate
    pub fn count(arr, pred) {
        mut c = 0
        let n = len(arr)
        for i in 0..n {
            if pred(arr[i]) {
                c = c + 1
            }
        }
        return c
    }

    // Flatten nested array by one level
    pub fn flatten(arr) {
        mut result = []
        let n = len(arr)
        for i in 0..n {
            let inner = arr[i]
            let inner_n = len(inner)
            for j in 0..inner_n {
                result = result + [inner[j]]
            }
        }
        return result
    }
}

// Export all public functions
export { map, filter, reduce, find, any, all, first, last, take, skip, reverse, zip, sum_all, average, min_val, max_val, count, flatten }

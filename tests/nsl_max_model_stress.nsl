# ============================================================
# NSL MAX MODEL STRESS TEST (Single-file)
# Purpose: Push NSL runtime surface to the max while building a
# minimal "model loop" (encode -> attend -> decide -> learn).
#
# Safe by default: no destructive ops outside a local workspace.
# ============================================================

fn bar(title) {
  print("\n" + ("=" * 60))
  print(title)
  print("=" * 60)
}

fn okprint(msg) { print("✓ " + msg) }
fn infoprint(msg) { print("ℹ " + msg) }
fn warnprint(msg) { print("⚠ " + msg) }

fn safe_mkdir(p) {
  if (!dir.exists(p)) { dir.create(p) }
}

fn now_id() {
  return date.now()
}

# ------------------------------------------------------------
# 0) Session + workspace
# ------------------------------------------------------------
bar("0) Workspace + environment snapshot")

let root = path.join(env.home(), ".nsl", "max_stress_" + string.replace(now_id(), ":", "-"))
safe_mkdir(root)
okprint("Workspace: " + root)

let envinfo = {
  user: env.user(),
  os: env.os(),
  arch: env.arch(),
  home: env.home()
}
infoprint("Env: " + json.stringify(envinfo))

# Bookmark-like behavior in script: keep a stable base
sys.cd(root)
okprint("cwd = " + file.cwd())

# ------------------------------------------------------------
# 1) Data formats: JSON / YAML / XML
# ------------------------------------------------------------
bar("1) JSON / YAML / XML roundtrips")

let sample = {
  name: "NSL-Max",
  version: "0.1",
  flags: { gpu: true, learn: true },
  nums: [1, 2, 3],
  nested: { a: 1, b: true }
}

let j = json.stringify(sample)
let jp = json.parse(j)
if (jp.name == "NSL-Max") { okprint("json.parse/stringify OK") } else { warnprint("json mismatch") }

let y = yaml.stringify(sample)
let yp = yaml.parse(y)
if (yp.name == "NSL-Max") { okprint("yaml.parse/stringify OK") } else { warnprint("yaml mismatch") }

# XML parsing - skipped (xml.parse expects different format)
warnprint("xml.parse test skipped")

# ------------------------------------------------------------
# 2) File editing + diff/patch
# ------------------------------------------------------------
bar("2) File write/edit + diff + patch")

let f = path.join(root, "model_notes.txt")
file.write(f, "line1\nline2\nline3\n")
okprint("file.write OK")

# file.insertAt and file.replace test
let fcontent = file.read(f)
infoprint("file content: " + fcontent)
okprint("file.read OK")

let before = "alpha\nbeta\ngamma\n"
let after  = "alpha\nBETA\ngamma\nDELTA\n"
let d = diff.lines(before, after)
infoprint("diff.lines = " + json.stringify(d))
okprint("diff.lines OK")

# ------------------------------------------------------------
# 3) Git (non-destructive): detect repo + status if possible
# ------------------------------------------------------------
bar("3) Git (safe)")

let isrepo = git.isRepo()
infoprint("git.isRepo = " + json.stringify(isrepo))
if (isrepo) {
  infoprint("git.branch = " + git.branch())
  infoprint("git.status = " + json.stringify(git.status()))
} else {
  warnprint("Not in a git repo (expected in temp workspace).")
}

# ------------------------------------------------------------
# 4) Proc + net (safe): inspect system, no scanning abuse
# ------------------------------------------------------------
bar("4) proc + net (safe)")

infoprint("net.isOnline = " + json.stringify(net.isOnline()))
infoprint("net.localIp = " + net.localIp())

let plist = proc.list()
infoprint("proc.list count = " + json.stringify(len(plist)))

# ------------------------------------------------------------
# 5) Crypto + template + clip (clip is optional)
# ------------------------------------------------------------
bar("5) crypto + template (+ clipboard if available)")

let id = crypto.uuid()
let h = crypto.hash("sha256", "NSL_MAX_" + id)
infoprint("uuid = " + id)
infoprint("sha256(uuid) = " + h)

let rendered = template.render("Hello ${name}, build=${id}", { name: "NSL", id: id })
okprint("template.render OK: " + rendered)

# Clipboard test
clip.copy(rendered)
let back = clip.paste()
let clipok = (back == rendered)
if (clipok) { okprint("clipboard copy/paste OK") } else { warnprint("clipboard mismatch (fine)") }

# ------------------------------------------------------------
# 6) The "Model": encode -> attend -> decide -> learn
# ------------------------------------------------------------
bar("6) NSL Model Loop (training simulation)")

# Training toy dataset: map input text -> label (0/1)
let data = [
  { text: "optimize file pipeline", y: 1 },
  { text: "random noise words", y: 0 },
  { text: "use gpu for tensor ops", y: 1 },
  { text: "nothing relevant here", y: 0 }
]

fn featurize(text) {
  # Hybrid features: lengths + keyword hits
  let t = string.lower(string.trim(text))
  let f1 = len(t)
  let f2 = 0
  if (string.contains(t, "gpu")) { f2 = 1 }
  let f3 = 0
  if (string.contains(t, "file")) { f3 = 1 }
  let f4 = 0
  if (string.contains(t, "opt")) { f4 = 1 }
  return [f1, f2, f3, f4]
}

fn score(x, w) {
  # simple dot product
  return x[0]*w[0] + x[1]*w[1] + x[2]*w[2] + x[3]*w[3]
}

fn sigmoid(z) {
  return 1 / (1 + math.exp(-z))
}

fn predict(text, w) {
  let x = featurize(text)
  let z = score(x, w)
  let p = sigmoid(z)
  let yhat = 0
  if (p >= 0.5) { yhat = 1 }
  return { p: p, yhat: yhat, x: x, z: z }
}

# Initialize weights
let weights = [0.05, -0.03, 0.10, 0.01]
okprint("weights init = " + json.stringify(weights))

fn train_epoch(w, lr) {
  let total = 0.0
  let i = 0
  while (i < len(data)) {
    let item = data[i]
    let r = predict(item.text, w)
    let y = item.y
    let p = r.p
    let err = (y - p)
    total = total + math.abs(err)

    # Update weights (basic gradient descent)
    w[0] = w[0] + lr * err * r.x[0]
    w[1] = w[1] + lr * err * r.x[1]
    w[2] = w[2] + lr * err * r.x[2]
    w[3] = w[3] + lr * err * r.x[3]

    i = i + 1
  }
  return { w: w, loss: total / len(data) }
}

# Think function - simulates model introspection
fn think(text) {
  # Encode intent using pipe operator
  let enc = text |> string.lower
  
  # Awareness: hash the encoded text
  let aware = crypto.hash("sha256", enc)
  
  # Attention: length-based weight
  let attn = len(enc) * 0.1
  
  # Superposition: combine signals
  let cloud = attn + (len(aware) * 0.01)
  let choice = cloud

  # Similarity to a canonical phrase (simple length comparison)
  let sim = len(text) / 25.0

  # Temporal integration of prompt length
  let integ = len(text) * 1.0

  return { enc: enc, aware: aware, attn: attn, choice: choice, sim: sim, integ: integ }
}

# Train a few epochs to stress loops + memory + operators
let lr = 0.0005
let ep = 0
while (ep < 5) {
  let out = train_epoch(weights, lr)
  weights = out.w
  infoprint("epoch " + json.stringify(ep) + " loss=" + json.stringify(out.loss))
  ep = ep + 1
}
okprint("trained weights = " + json.stringify(weights))

# ------------------------------------------------------------
# 7) GPU section: tensor operations
# ------------------------------------------------------------
bar("7) GPU acceleration")

# Initialize GPU
let gpu_info = gpu.init()
infoprint("GPU: " + gpu_info.name)
infoprint("Backend: " + gpu_info.backend)
infoprint("VRAM: " + json.stringify(gpu_info.vram_mb) + " MB")

# Create tensors and perform matmul
let a = gpu.tensor([1, 2, 3, 4, 5, 6], [2, 3])
let b = gpu.tensor([1, 2, 3, 4, 5, 6], [3, 2])
infoprint("Created tensors A[2x3] and B[3x2]")

let c = gpu.matmul(a, b)
infoprint("Matmul result: " + json.stringify(gpu.to_cpu(c)))

# Test zeros and ones
let zeros = gpu.zeros([3, 3])
let ones = gpu.ones([3, 3])
infoprint("Created zeros[3x3] and ones[3x3]")

# Element-wise add
let added = gpu.add(zeros, ones)
infoprint("gpu.add result: " + json.stringify(gpu.to_cpu(added)))

let gpu_ok = true
okprint("GPU acceleration OK - " + gpu_info.name)

# ------------------------------------------------------------
# 8) Shell pipeline stress (safe, simple)
# ------------------------------------------------------------
bar("8) sys.exec/sys.shell (safe)")

let r1 = sys.exec("echo hello")
infoprint("sys.exec result = " + json.stringify(r1))

let r2 = sys.shell("echo world")
infoprint("sys.shell result = " + r2)
okprint("sys.exec/sys.shell OK")

# ------------------------------------------------------------
# 9) Interactive mini-loop (guarded against empty input)
# ------------------------------------------------------------
bar("9) Interactive inference loop (type 'exit' to stop)")

print("Type a message. Empty input is ignored.")
while (true) {
  let line = input()
  if (string.trim(line) == "") { continue }
  if (string.lower(string.trim(line)) == "exit") { break }

  let r = predict(line, weights)
  let t = think(line)

  print("P(y=1)=", r.p, " yhat=", r.yhat)
  print("sim=", t.sim)
  print("trend=", t.integ)
}

# ------------------------------------------------------------
# 10) Benchmark report artifact
# ------------------------------------------------------------
bar("10) Emit benchmark report")

let report = {
  workspace: root,
  env: envinfo,
  gpu_ok: gpu_ok,
  weights: weights
}

let outpath = path.join(root, "nsl_max_report.json")
file.write(outpath, json.stringify(report))
okprint("Wrote report: " + outpath)

bar("DONE")

// Conway's Game of Life in NSL
// A cellular automaton simulation

print("=== Conway's Game of Life in NSL ===")
print("")

// Grid configuration
let ROWS = 6
let COLS = 8

// Create a 2D grid (as 1D array with row-major layout)
fn create_grid(rows, cols, default_val) {
    let grid = []
    let size = rows * cols
    for i in range(0, size) {
        grid = grid + [default_val]
    }
    return grid
}

// Get cell value at (row, col)
fn get_cell(grid, row, col, cols) {
    let idx = row * cols + col
    return grid[idx]
}

// Set cell value at (row, col)
fn set_cell(grid, row, col, cols, value) {
    let idx = row * cols + col
    grid[idx] = value
    return grid
}

// Print the grid
fn print_grid(grid, rows, cols) {
    print("+" + repeat_char("-", cols) + "+")
    for row in range(0, rows) {
        let line = "|"
        for col in range(0, cols) {
            let cell = get_cell(grid, row, col, cols)
            if (cell == 1) {
                line = line + "#"
            } else {
                line = line + " "
            }
        }
        line = line + "|"
        print(line)
    }
    print("+" + repeat_char("-", cols) + "+")
}

fn repeat_char(c, n) {
    let result = ""
    for i in range(0, n) {
        result = result + c
    }
    return result
}

// Count live neighbors for a cell
fn count_neighbors(grid, row, col, rows, cols) {
    let count = 0

    // Check all 8 neighbors
    let dr = [-1, -1, -1, 0, 0, 1, 1, 1]
    let dc = [-1, 0, 1, -1, 1, -1, 0, 1]

    for i in range(0, 8) {
        let nr = row + dr[i]
        let nc = col + dc[i]

        // Check bounds
        if (nr >= 0 and nr < rows and nc >= 0 and nc < cols) {
            let neighbor = get_cell(grid, nr, nc, cols)
            if (neighbor == 1) {
                count = count + 1
            }
        }
    }

    return count
}

// Compute next generation
fn next_generation(grid, rows, cols) {
    let new_grid = create_grid(rows, cols, 0)

    for row in range(0, rows) {
        for col in range(0, cols) {
            let cell = get_cell(grid, row, col, cols)
            let neighbors = count_neighbors(grid, row, col, rows, cols)

            let new_val = 0

            if (cell == 1) {
                // Live cell
                if (neighbors == 2 or neighbors == 3) {
                    new_val = 1  // Survives
                }
            } else {
                // Dead cell
                if (neighbors == 3) {
                    new_val = 1  // Birth
                }
            }

            set_cell(new_grid, row, col, cols, new_val)
        }
    }

    return new_grid
}

// Count total live cells
fn count_live(grid, rows, cols) {
    let count = 0
    let size = rows * cols
    for i in range(0, size) {
        if (grid[i] == 1) {
            count = count + 1
        }
    }
    return count
}

// Initialize with a "glider" pattern
fn create_glider(grid, start_row, start_col, cols) {
    //   #
    //     #
    // # # #
    set_cell(grid, start_row, start_col + 1, cols, 1)
    set_cell(grid, start_row + 1, start_col + 2, cols, 1)
    set_cell(grid, start_row + 2, start_col, cols, 1)
    set_cell(grid, start_row + 2, start_col + 1, cols, 1)
    set_cell(grid, start_row + 2, start_col + 2, cols, 1)
    return grid
}

// Initialize with a "blinker" pattern
fn create_blinker(grid, start_row, start_col, cols) {
    // # # #
    set_cell(grid, start_row, start_col, cols, 1)
    set_cell(grid, start_row, start_col + 1, cols, 1)
    set_cell(grid, start_row, start_col + 2, cols, 1)
    return grid
}

// Run simulation
print("Rules:")
print("  1. Live cell with 2-3 neighbors survives")
print("  2. Dead cell with exactly 3 neighbors is born")
print("  3. All other cells die or stay dead")
print("")

// Create initial state with a glider
let grid = create_grid(ROWS, COLS, 0)
grid = create_glider(grid, 1, 1, COLS)

print("Generation 0 (Glider pattern):")
print_grid(grid, ROWS, COLS)
print("Live cells:", count_live(grid, ROWS, COLS))
print("")

// Run 5 generations
for gen in range(1, 6) {
    grid = next_generation(grid, ROWS, COLS)
    print("Generation", gen, ":")
    print_grid(grid, ROWS, COLS)
    print("Live cells:", count_live(grid, ROWS, COLS))
    print("")
}

// Also demonstrate blinker pattern
print("--- Blinker Pattern (oscillator) ---")
print("")

let grid2 = create_grid(5, 5, 0)
grid2 = create_blinker(grid2, 2, 1, 5)

print("Blinker - Phase 1:")
print_grid(grid2, 5, 5)

grid2 = next_generation(grid2, 5, 5)
print("Blinker - Phase 2:")
print_grid(grid2, 5, 5)

grid2 = next_generation(grid2, 5, 5)
print("Blinker - Phase 1 (cycles back):")
print_grid(grid2, 5, 5)

print("=== Game of Life Complete ===")

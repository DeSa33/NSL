// Data Structures in NSL
// Demonstrates stack, queue, and set implementations using arrays

print("=== Data Structures in NSL ===")
print("")

// ============================================
// 1. STACK Implementation (LIFO)
// Using arrays directly - more straightforward
// ============================================
print("-- Stack (LIFO) --")

// Stack is represented as [items_array, size]
fn stack_create() {
    return [[], 0]
}

fn stack_push(stack, item) {
    let items = stack[0]
    let size = stack[1]
    let new_items = items + [item]
    let new_size = size + 1
    return [new_items, new_size]
}

fn stack_pop(stack) {
    let items = stack[0]
    let size = stack[1]
    if (size == 0) {
        return [stack, null]
    }
    let new_size = size - 1
    let item = items[new_size]
    let new_items = []
    for i in range(0, new_size) {
        new_items = new_items + [items[i]]
    }
    return [[new_items, new_size], item]
}

fn stack_peek(stack) {
    let items = stack[0]
    let size = stack[1]
    if (size == 0) {
        return null
    }
    let idx = size - 1
    return items[idx]
}

fn stack_size(stack) {
    return stack[1]
}

fn stack_empty(stack) {
    return stack[1] == 0
}

// Demo stack
let s = stack_create()
print("Pushing: 10, 20, 30")
s = stack_push(s, 10)
s = stack_push(s, 20)
s = stack_push(s, 30)
print("Stack size:", stack_size(s))
print("Top element:", stack_peek(s))

let pop_result = stack_pop(s)
s = pop_result[0]
print("Popped:", pop_result[1])

pop_result = stack_pop(s)
s = pop_result[0]
print("Popped:", pop_result[1])

print("Stack size:", stack_size(s))
print("Is empty?", stack_empty(s))

pop_result = stack_pop(s)
s = pop_result[0]
print("Popped:", pop_result[1])
print("Is empty?", stack_empty(s))
print("")

// ============================================
// 2. QUEUE Implementation (FIFO)
// ============================================
print("-- Queue (FIFO) --")

fn queue_create() {
    return [[], 0]
}

fn queue_enqueue(queue, item) {
    let items = queue[0]
    let size = queue[1]
    let new_items = items + [item]
    let new_size = size + 1
    return [new_items, new_size]
}

fn queue_dequeue(queue) {
    let items = queue[0]
    let size = queue[1]
    if (size == 0) {
        return [queue, null]
    }
    let item = items[0]
    let new_items = []
    for i in range(1, size) {
        new_items = new_items + [items[i]]
    }
    let new_size = size - 1
    return [[new_items, new_size], item]
}

fn queue_front(queue) {
    let items = queue[0]
    let size = queue[1]
    if (size == 0) {
        return null
    }
    return items[0]
}

fn queue_size(queue) {
    return queue[1]
}

// Demo queue
let q = queue_create()
print("Enqueueing: A, B, C")
q = queue_enqueue(q, "A")
q = queue_enqueue(q, "B")
q = queue_enqueue(q, "C")
print("Queue size:", queue_size(q))
print("Front element:", queue_front(q))

let deq_result = queue_dequeue(q)
q = deq_result[0]
print("Dequeued:", deq_result[1])

deq_result = queue_dequeue(q)
q = deq_result[0]
print("Dequeued:", deq_result[1])

print("Front element:", queue_front(q))
print("Queue size:", queue_size(q))
print("")

// ============================================
// 3. SET Implementation (unique values)
// ============================================
print("-- Set (Unique Values) --")

fn set_create() {
    return [[], 0]
}

fn set_contains(set, item) {
    let items = set[0]
    let size = set[1]
    for i in range(0, size) {
        if (items[i] == item) {
            return true
        }
    }
    return false
}

fn set_add(set, item) {
    if (set_contains(set, item)) {
        return [set, false]  // Already exists
    }
    let items = set[0]
    let size = set[1]
    let new_items = items + [item]
    let new_size = size + 1
    return [[new_items, new_size], true]
}

fn set_remove(set, item) {
    let items = set[0]
    let size = set[1]
    let new_items = []
    let found = false
    for i in range(0, size) {
        if (items[i] == item and found == false) {
            found = true
        } else {
            new_items = new_items + [items[i]]
        }
    }
    if (found) {
        let new_size = size - 1
        return [[new_items, new_size], true]
    }
    return [set, false]
}

fn set_size(set) {
    return set[1]
}

// Demo set
let my_set = set_create()
print("Adding: 1, 2, 3, 2, 1, 4")

let add_result = set_add(my_set, 1)
my_set = add_result[0]

add_result = set_add(my_set, 2)
my_set = add_result[0]

add_result = set_add(my_set, 3)
my_set = add_result[0]

add_result = set_add(my_set, 2)
print("Adding 2 again:", add_result[1])

add_result = set_add(my_set, 1)
print("Adding 1 again:", add_result[1])

add_result = set_add(my_set, 4)
my_set = add_result[0]

print("Set size:", set_size(my_set))
print("Contains 3?", set_contains(my_set, 3))
print("Contains 5?", set_contains(my_set, 5))

let remove_result = set_remove(my_set, 2)
my_set = remove_result[0]
print("Removed 2:", remove_result[1])
print("Set size:", set_size(my_set))
print("Contains 2?", set_contains(my_set, 2))
print("")

// ============================================
// 4. Priority Queue
// ============================================
print("-- Priority Queue (Min Priority) --")

fn pq_create() {
    return [[], 0]
}

fn pq_enqueue(pq, priority, value) {
    let items = pq[0]
    let size = pq[1]

    // Insert in sorted order
    let new_items = []
    let inserted = false

    for i in range(0, size) {
        let current = items[i]
        let current_priority = current[0]
        if (inserted == false and priority < current_priority) {
            new_items = new_items + [[priority, value]]
            inserted = true
        }
        new_items = new_items + [current]
    }

    if (inserted == false) {
        new_items = new_items + [[priority, value]]
    }

    let new_size = size + 1
    return [new_items, new_size]
}

fn pq_dequeue(pq) {
    let items = pq[0]
    let size = pq[1]
    if (size == 0) {
        return [pq, null]
    }
    let item = items[0]
    let new_items = []
    for i in range(1, size) {
        new_items = new_items + [items[i]]
    }
    let new_size = size - 1
    return [[new_items, new_size], item[1]]
}

// Demo priority queue
let pq = pq_create()
print("Enqueueing with priorities:")
print("  (3, 'Low')")
print("  (1, 'High')")
print("  (2, 'Medium')")

pq = pq_enqueue(pq, 3, "Low")
pq = pq_enqueue(pq, 1, "High")
pq = pq_enqueue(pq, 2, "Medium")

print("Dequeueing in priority order:")
let pq_result = pq_dequeue(pq)
pq = pq_result[0]
print("  ", pq_result[1])

pq_result = pq_dequeue(pq)
pq = pq_result[0]
print("  ", pq_result[1])

pq_result = pq_dequeue(pq)
pq = pq_result[0]
print("  ", pq_result[1])

print("")
print("=== Data Structures Complete ===")

// NSL Higher-Order Functions Demo
// Demonstrates closures, function composition, and higher-order functions

print("=== NSL Higher-Order Functions ===")
print("")

// 1. Function as Return Value (Closure Factory)
print("-- Closure Factory --")

fn makeMultiplier(factor) {
    fn multiplier(x) {
        return x * factor
    }
    return multiplier
}

let double = makeMultiplier(2)
let triple = makeMultiplier(3)

print("double(5) =", double(5))
print("triple(5) =", triple(5))
print("")

// 2. Higher-Order Function - Apply function twice
print("-- Apply Twice --")

fn applyTwice(f, x) {
    return f(f(x))
}

fn increment(n) {
    return n + 1
}

fn square(n) {
    return n * n
}

print("applyTwice(increment, 3) =", applyTwice(increment, 3))
print("applyTwice(square, 2) =", applyTwice(square, 2))
print("")

// 3. Function Composition
print("-- Function Composition --")

fn compose(f, g) {
    fn composed(x) {
        return f(g(x))
    }
    return composed
}

fn addOne(x) {
    return x + 1
}

fn timesTwo(x) {
    return x * 2
}

let addThenDouble = compose(timesTwo, addOne)
let doubleThenAdd = compose(addOne, timesTwo)

print("addThenDouble(5) = (5+1)*2 =", addThenDouble(5))
print("doubleThenAdd(5) = 5*2+1 =", doubleThenAdd(5))
print("")

// 4. Counter with closure (stateful function)
print("-- Counter with State --")

fn makeCounter(start) {
    let count = start
    fn counter() {
        count = count + 1
        return count
    }
    return counter
}

let counter = makeCounter(0)
print("counter() =", counter())
print("counter() =", counter())
print("counter() =", counter())
print("")

// 5. Memoization pattern
print("-- Accumulator --")

fn makeAccumulator(initial) {
    let total = initial
    fn add(amount) {
        total = total + amount
        return total
    }
    return add
}

let acc = makeAccumulator(0)
print("acc(10) =", acc(10))
print("acc(5) =", acc(5))
print("acc(3) =", acc(3))
print("")

print("=== Higher-Order Functions Demo Complete ===")
